 Deploying a .NET Core app on Windows Server
 
1. Assign a DNS name to the VM
2. Add a rule for port 8172 to the NSG
3. Add the role of the management service on the VM
4. Check the configuration of the Management service in IIS
5. Install the .net hosting bundle. This allows .net applications to be hosted on IIS
6. Install web deploy v3.6 tool


1. Go to VM overview -> DNS Name -> Click Not configured link -> enter name -> save

2. Add inbound rule for Allow for the port 8172, service -Custom and save this 

3. Server roles -> Web server (IIS) -> Management Tools -> Management services -> Add feature -> install

4. Go to Application in IIS -> Click on the application -> Management services -> Click Enable remote connections (notice this has port number 8172 enabled, that is the reason why we created inbound rule for that port. ) -> Apply 

5.Local server -> IE Enhanced security configuration -> Off for sometime ->  Download .net version you want to serve your application
We only need hosting bundle

6. Download web deploy tool


From your visual studio you can publish your web project. If you want to add your account then Tools -> Options -> Azure Service Authentication -> Choose an account for publish 

We need to login to azure credentials, choose our target VM, subscribtion, Resource group etc and publish. This will create a publish profile 


Instead of creating inbound rule for HTTP port 80 after creating the VM, we can also allow inbound port while creating the VM


Deploying .net app on the Linux VM

We need putty application to connect with Linux VM

1. Host name - Public IP address -> Open -> Yes

Give credentials

2. To publish into Linux -> Create new publish profile -> Folder (local folder or file share - it will create publish version of the project in bin\release\net6.0\publish) -> Publish

3. We need to copy all artifacts from local to linux server using winSCP

4. Host name , Uname and password -> WinSCP connected to the Linux
Left hand side is your local machine, and right hand side is the linux server -> drag and drop folder to Linux after copy is complete go to the terminal type pwd (present working directory) -> ls (list)


5. We need to install .net runtime on ubuntu also, for that we can see the instruction from Microsoft 

Before install .NET, we need to add microsoft package signing key to your list of trusted keys and add the package repository then we can install SDK

dotnet webapp.dll -> 

Duplicate the session and run "curl http://localhost:5000 we will get the response 
	 



nginx is the webserver for Linux, to install it in linux

sudo get-apt install nginx

to do any configuration changes into linux server nginx we need to stop the server using the command sudo service nginx stop
 

We are inside the Home folder by default click one level up -> etc -> nginx -> sites-available-> default, right click and see the permission for this file, it is 644 we can change its permission to 777 and edit it 

command to change permission is sudo chmod 777 default 

Replace the location configuration to the below

location / {
proxy_pass Http://localhost:5000;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection Keep-alive;
proxy_set_header Host $host;
proxy_cache_bypass $http_upgrade;

}

now start the service again 

sudo service nginx start -> now click on the public IP address then instead of nginx page our web application page will be displaying 


Click on Publish -> Select Azure -> Select Resource group and app service from visual studio


Azure SQL database

When we use VM and install SQL server then you need to configure the server, configure for high availability and configure backups etc. 

But if you choose Azure SQL database then the above mentioned points are taken care by azure itself. 


When we create Azure SQL we will create two resources one is SQL server and one database. 

We can configure which authentication we want and then we can choose network connectivity

  * No Access
  * Public endpoint
  * Private endpoint 

Fireware rules 

Allow Azure services and resources to access this server to yes 

Add current client IP to connect with the database



Publishing from Github
====================

Deployment -> Deployment Settings -> Continous deployment -> Enable 

Github actions -> we can configure when creating app service 

Another way Git -> Git repository->  Create and push -> this will create repository in local and then push those changes to git

Deployment center -> Settings -> Source -> Github -> Repository , Branch, RunTime save 

Go to logs ->  you can see log of deployment . 

If you change and Git changes -> comments and commit then push push. If you go to the github then changes will be reflected. Go to webapp and see the logs
it will show changes in progress or completed. another log we can find. If we invoke the url new content can be seen.


Using the Azure Web app connection string 

We can create connecting string under 

Configuration -> App settings -> Connecting string ->  Value (connecting string ) , Type SQLAzure, Name (connection string name) 


in service class we need Iconfiguration interface to invoke this connection string 

private readonly Iconfiguartion _configuration; 

public ProductService(Iconfiguartion _iConfiguartion  )
{
_configuration = _iconfiguration ; 
}


to get the connection string we need

_configuration.getConnectionString("ConnectionString")




Azure app service logging 

1. Application logging (app code generated error )
2. Web server logging (Raw HTTP request date)
3. Detailed error message (Copies of .htm error pages)
4. Deployment logging 



App service -> app service log -> Application logging (filesystem)
Level 

If you dont want to use existing file system you can keep you logs in seperate storage account. 


app service -> Log stream -> where you can see live loggin 


Azure Web Apps Autoscaling 

Auto scaling features ensures that our web app serves better when there is a change in demand. If the demand is high then it automatically add more VMs and the other way around. 
This autoscaling is manual process and if you need automatic process then you need to go for standard pricing plan. Notice there is no automatic autoscaling in basic and free tiers. We are doing autoscaling on pricing plan not on the app service. Because all app services are priced based on this service plan only. 

Scale up -> change pricing plan
Scale out -> auto scaling rule. 


We can add our custom rule, If my app service's hosting machine

 CPU percentage is above 70%
 for the continous 10 mins
 add another instances
 Maximum you can add 3 instances
 after adding instances wait for 5(cool down time) mins to allow the changes to take effect. 

This is sample rule, you can also configure scale in rule to reduce the instances as well. 

If you see the service plan you can see S1:3. Means now your app service plan is running 3 machines . 

Go to Run history -> Resource instance count will show number of machine instances running 

Operation name -> autoscaling done log will be there 


Azure Web apps -> Custom domains

We need to get custom domains from 3rd party vendors like goDaddy. 

Go to custom domains in the app service -> Add Custom domain -> enter domain and click validate. 

Now Azure will give two types of record "A" and "TXT" records, you need to copy the value from Azure to your 3rd party vendor. This will ensure you own that domain. 

After update this, wait for 10 mins to take changes effect. then again go to azure and add custom domain and validate. Now azure should show validated custom domain, and then add custom domain. Now if you give your custom domain then your web app should be shown. 

Still we need to add SSL certificates to this custom domain otherwise connection is not secure error will be shown in the browser. 


To do this Go to App service -> TLS/SSL settings -> Private key certificates (.pfx) (usually we need to buy certificate, but we are going to use a certificate provided by azure now) 	

Add custom domain name and certificate friendly name. You cannot download this certificate as this is managed by app service. 

Now go back to custom domain -> Add binding ->  Choose private certificate thumbprint -> TLS/SSL Type SNI SSL -> add binding 



Deployment slots

Deployment slots are available in Standard and premium app service plan 

With Deployment slots you have ability to validate application changes in the staging deployment slot and you can swap the staging slot with the production slot. 

This helps eliminate the downtime for your application during deployment 

you can easily swap deployment slots in case of issues. 


Deployment slots will have unique URLs just like differents webapps


Add Deployment slot, then we have option to configure how much traffic to go to another deployment slot. While publishing, we need to select app service and expand deployment slot and select particular deployment slot and then publish 

We have swap option to use which deployment slot. 


When we swap environment we need to wait for warm up time to take effect the swap. We can improve this warmup time by setting up custom warm up 


Deployment slots with Databases

While creating app config click on "Deployment slot setting" checkbox while create app configuration . If we do that then while doing a deployment slot, this will not be copied to new deployment slot. 


Azure App configuration

We have seen that we have configured connection string in web application (configuration section ) itself. But we may have multiple configuration that can be saved in centralized place called App Configuration


Create New resource -> App configuration ->  After resource created -> Configuration explorer -> Create -> key-value ->  give connecting string key value pair and save


To use this we need to install AzureAppConfig nuget package in our project 

App configuration -> Access Keys -> we can take primary key or secondary key. 

var constr='primary key copied from azure app config'

builder.Host.COnfigureAppCOnfiguration(builder => {
builder.AddAzureAppConfigration(constr);
})



Feature flag 

This allows us to toggle on and off based on the need. 

App COnfiguration -> Feature manager -> Add -> name -> Apply 

Install Microsoft.FeatureManagement nuget package.

on builder services in program.cs 
builder.Services.AddFeatureManagement();

builder.Host.COnfigureAppCOnfiguration(options => {
options.connect(constr).UseFeatureFlags();
})


in service 

private readonly IFeatureManager _featureManger

public async Task<bool> IsBeta()
{
return await _featureManager.IsEnabledAsync("beta");
}


We can use this featureflag to control controllers or actions like below

using Microsoft.FeatureManagement;

[FeatureGate(MyFeatureFlags.FeatureA)]
public IActionResult Index()
{
}

