 Deploying a .NET Core app on Windows Server
 
1. Assign a DNS name to the VM
2. Add a rule for port 8172 to the NSG
3. Add the role of the management service on the VM
4. Check the configuration of the Management service in IIS
5. Install the .net hosting bundle. This allows .net applications to be hosted on IIS
6. Install web deploy v3.6 tool


1. Go to VM overview -> DNS Name -> Click Not configured link -> enter name -> save

2. Add inbound rule for Allow for the port 8172, service -Custom and save this 

3. Server roles -> Web server (IIS) -> Management Tools -> Management services -> Add feature -> install

4. Go to Application in IIS -> Click on the application -> Management services -> Click Enable remote connections (notice this has port number 8172 enabled, that is the reason why we created inbound rule for that port. ) -> Apply 

5.Local server -> IE Enhanced security configuration -> Off for sometime ->  Download .net version you want to serve your application
We only need hosting bundle

6. Download web deploy tool


From your visual studio you can publish your web project. If you want to add your account then Tools -> Options -> Azure Service Authentication -> Choose an account for publish 

We need to login to azure credentials, choose our target VM, subscribtion, Resource group etc and publish. This will create a publish profile 


Instead of creating inbound rule for HTTP port 80 after creating the VM, we can also allow inbound port while creating the VM


Deploying .net app on the Linux VM

We need putty application to connect with Linux VM

1. Host name - Public IP address -> Open -> Yes

Give credentials

2. To publish into Linux -> Create new publish profile -> Folder (local folder or file share - it will create publish version of the project in bin\release\net6.0\publish) -> Publish

3. We need to copy all artifacts from local to linux server using winSCP

4. Host name , Uname and password -> WinSCP connected to the Linux
Left hand side is your local machine, and right hand side is the linux server -> drag and drop folder to Linux after copy is complete go to the terminal type pwd (present working directory) -> ls (list)


5. We need to install .net runtime on ubuntu also, for that we can see the instruction from Microsoft 

Before install .NET, we need to add microsoft package signing key to your list of trusted keys and add the package repository then we can install SDK

dotnet webapp.dll -> 

Duplicate the session and run "curl http://localhost:5000 we will get the response 
	 



nginx is the webserver for Linux, to install it in linux

sudo get-apt install nginx

to do any configuration changes into linux server nginx we need to stop the server using the command sudo service nginx stop
 

We are inside the Home folder by default click one level up -> etc -> nginx -> sites-available-> default, right click and see the permission for this file, it is 644 we can change its permission to 777 and edit it 

command to change permission is sudo chmod 777 default 

Replace the location configuration to the below

location / {
proxy_pass Http://localhost:5000;
proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection Keep-alive;
proxy_set_header Host $host;
proxy_cache_bypass $http_upgrade;

}

now start the service again 

sudo service nginx start -> now click on the public IP address then instead of nginx page our web application page will be displaying 


Click on Publish -> Select Azure -> Select Resource group and app service from visual studio


Azure SQL database

When we use VM and install SQL server then you need to configure the server, configure for high availability and configure backups etc. 

But if you choose Azure SQL database then the above mentioned points are taken care by azure itself. 


When we create Azure SQL we will create two resources one is SQL server and one database. 

We can configure which authentication we want and then we can choose network connectivity

  * No Access
  * Public endpoint
  * Private endpoint 

Fireware rules 

Allow Azure services and resources to access this server to yes 

Add current client IP to connect with the database



Publishing from Github
====================

Deployment -> Deployment Settings -> Continous deployment -> Enable 

Github actions -> we can configure when creating app service 

Another way Git -> Git repository->  Create and push -> this will create repository in local and then push those changes to git

Deployment center -> Settings -> Source -> Github -> Repository , Branch, RunTime save 

Go to logs ->  you can see log of deployment . 

If you change and Git changes -> comments and commit then push push. If you go to the github then changes will be reflected. Go to webapp and see the logs
it will show changes in progress or completed. another log we can find. If we invoke the url new content can be seen.


Using the Azure Web app connection string 

We can create connecting string under 

Configuration -> App settings -> Connecting string ->  Value (connecting string ) , Type SQLAzure, Name (connection string name) 


in service class we need Iconfiguration interface to invoke this connection string 

private readonly Iconfiguartion _configuration; 

public ProductService(Iconfiguartion _iConfiguartion  )
{
_configuration = _iconfiguration ; 
}


to get the connection string we need

_configuration.getConnectionString("ConnectionString")




Azure app service logging 

1. Application logging (app code generated error )
2. Web server logging (Raw HTTP request date)
3. Detailed error message (Copies of .htm error pages)
4. Deployment logging 



App service -> app service log -> Application logging (filesystem)
Level 

If you dont want to use existing file system you can keep you logs in seperate storage account. 


app service -> Log stream -> where you can see live loggin 


Azure Web Apps Autoscaling 

Auto scaling features ensures that our web app serves better when there is a change in demand. If the demand is high then it automatically add more VMs and the other way around. 
This autoscaling is manual process and if you need automatic process then you need to go for standard pricing plan. Notice there is no automatic autoscaling in basic and free tiers. We are doing autoscaling on pricing plan not on the app service. Because all app services are priced based on this service plan only. 

Scale up -> change pricing plan
Scale out -> auto scaling rule. 


We can add our custom rule, If my app service's hosting machine

 CPU percentage is above 70%
 for the continous 10 mins
 add another instances
 Maximum you can add 3 instances
 after adding instances wait for 5(cool down time) mins to allow the changes to take effect. 

This is sample rule, you can also configure scale in rule to reduce the instances as well. 

If you see the service plan you can see S1:3. Means now your app service plan is running 3 machines . 

Go to Run history -> Resource instance count will show number of machine instances running 

Operation name -> autoscaling done log will be there 


Azure Web apps -> Custom domains

We need to get custom domains from 3rd party vendors like goDaddy. 

Go to custom domains in the app service -> Add Custom domain -> enter domain and click validate. 

Now Azure will give two types of record "A" and "TXT" records, you need to copy the value from Azure to your 3rd party vendor. This will ensure you own that domain. 

After update this, wait for 10 mins to take changes effect. then again go to azure and add custom domain and validate. Now azure should show validated custom domain, and then add custom domain. Now if you give your custom domain then your web app should be shown. 

Still we need to add SSL certificates to this custom domain otherwise connection is not secure error will be shown in the browser. 


To do this Go to App service -> TLS/SSL settings -> Private key certificates (.pfx) (usually we need to buy certificate, but we are going to use a certificate provided by azure now) 	

Add custom domain name and certificate friendly name. You cannot download this certificate as this is managed by app service. 

Now go back to custom domain -> Add binding ->  Choose private certificate thumbprint -> TLS/SSL Type SNI SSL -> add binding 



Deployment slots

Deployment slots are available in Standard and premium app service plan 

With Deployment slots you have ability to validate application changes in the staging deployment slot and you can swap the staging slot with the production slot. 

This helps eliminate the downtime for your application during deployment 

you can easily swap deployment slots in case of issues. 


Deployment slots will have unique URLs just like differents webapps


Add Deployment slot, then we have option to configure how much traffic to go to another deployment slot. While publishing, we need to select app service and expand deployment slot and select particular deployment slot and then publish 

We have swap option to use which deployment slot. 


When we swap environment we need to wait for warm up time to take effect the swap. We can improve this warmup time by setting up custom warm up 


Deployment slots with Databases

While creating app config click on "Deployment slot setting" checkbox while create app configuration . If we do that then while doing a deployment slot, this will not be copied to new deployment slot. 


Azure App configuration

We have seen that we have configured connection string in web application (configuration section ) itself. But we may have multiple configuration that can be saved in centralized place called App Configuration


Create New resource -> App configuration ->  After resource created -> Configuration explorer -> Create -> key-value ->  give connecting string key value pair and save


To use this we need to install AzureAppConfig nuget package in our project 

App configuration -> Access Keys -> we can take primary key or secondary key. 

var constr='primary key copied from azure app config'

builder.Host.COnfigureAppCOnfiguration(builder => {
builder.AddAzureAppConfigration(constr);
})



Feature flag 

This allows us to toggle on and off based on the need. 

App COnfiguration -> Feature manager -> Add -> name -> Apply 

Install Microsoft.FeatureManagement nuget package.

on builder services in program.cs 
builder.Services.AddFeatureManagement();

builder.Host.COnfigureAppCOnfiguration(options => {
options.connect(constr).UseFeatureFlags();
})


in service 

private readonly IFeatureManager _featureManger



Section 4

Azure Function is serverless , we need to associate Storage account to work with Azure Functions

We can choose Plan type as 
	* Consumption based (serverless)
	* App service plan 
	* Functions Premium 


Create a function 

Development envioronment - Develop in portal
Select a template -  HTTP trigger
Template Detail - Give name for function 

Code + Test -> some template will be already written 
public async Task<bool> IsBeta()
{
return await _featureManager.IsEnabledAsync("beta");
}


We can use this featureflag to control controllers or actions like below

using Microsoft.FeatureManagement;

[FeatureGate(MyFeatureFlags.FeatureA)]
public IActionResult Index()
{
}

If we create azure function from visual studio and publish to azure then we cannot edit code from azure. we can only edit function.json file. 

Same as Webapps, we can also add connection string in function app. Go to FunctionApp -> Configuration -> Connection String -> 


Environment.GetEnvironmentVariable("SQLAZURECONNSTR_SQLConnectionstring") , SQLAZURECONNSTR is mandatory to include before your connectionstring 



Section 5 

Sudo docker images - will give list of docker available on our linux machine

sudo docker run --name appngnix -p 80:80  -d nginx



(first 80 is the port for the container, container will listen to port 80 and that port is alinged with the Virual machine's port 80)  


sudo docker ps - this will give running dockers 

What is docker file -> docker file will have information for the docker runtime on how to build an image. 

Here we will create publish version of sqlapp application and copy to home/linuxuser via the winscp tool. 


SAMPLE DOCKER FILE 

FROM  mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY..
EXPOSE 80
ENTRYPOINT ["dotnet","applicationname.dll"]



to build docker use below command 

sudo docker build -t sqlapp . (docker file should be in your current working directory)

to stop and container

sudo dockefr stop 9ec (this can be full id of the container or first 3 characters)


to remove container from docker runtime 

sudo docker rm d90
 

What is Azure container registory?

It is same as docker hub its a private version repositroy. 


Go to Azure container registory -> Access keys -> Enable Admin user then you can see username and password to connect to  container registory


Install Azure CLI in Linux 


To login to azure container registory 

az acr login --name registoryname --username uname --password 

login succeeded 

to tag our image on this container registory 

sudo docker tag sqlapp appregistory300030.azurecr.io/sqlapp(sqlapp is image name)

sudo docker push appregistory300030.azurecr.io/sqlapp



Azure Container instances	

Once we create an image then we need to create publish build of the application and copy that publish files into linux machine, then create a docker file end run the docker.

This can be simplified using container instances, once your image is ready map it with an instance then you have your image up and running, underlying infrastructre is managed for you. 

1. Provides a fast and easy way to deploy containers
2. This is managed instance, docker installation and configuration everything will be managed for you (underlying infrastructure)
3. ACI can also get their own public IP and DNS name 
4. You can also persist data via the use of azure file shares. 


Ceate Resource -> Container Instance -> 
Image source 
	* Quickstart images (Microsoft)
	* Azure Container Registry 
	* Other registry (from docker hub)
We can create image and its tag, which one we need . You needed to enable admin user in Azure container registory to access that in Container instances 

Networking Type -> public / Private 
Port -> 80 we are exposing on port 80. 

Review and create will create a container based on the image we gave.

Go to containers we can see state of the container, properties, logs etc. 


Multi Stage builds. 

Remember, the size of the image is based on the instruction we give to that image. For example in nginx image is lightweight. it will only have bare minimum things to serve as a web server will not have entire linux features. 

Similarly, if you see dotnet images, it will have dotnet runtime so it will be bigger in size. 



Instead of doing build and get publish version on our local and then port that to image we can give this as instruction to docker file 


FROM mcr.microsoft/dotnet/sdk:6.0 
WORKDIR /source  -- we are creating a working directory 
COPY *.csproj ./

COPY ..
RUN dotnet restore 

COPY .. 
RUN dotnet publish -c Release  -o out


 FROM  mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY..
EXPOSE 80
ENTRYPOINT ["dotnet","applicationname.dll"]



If we run this as it is. this will create layer by layers. we can create stages by doing this if that stage is done then it will remove that layer 


FROM mcr.microsoft/dotnet/sdk:6.0  AS build 
WORKDIR /source  -- we are creating a working directory 
COPY *.csproj ./

COPY ..
RUN dotnet restore 

COPY .. 
RUN dotnet publish -c Release  -o out  -- this step create an out folder without source folder


 FROM  mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=build /source/out .   -- we are copying out folder 
EXPOSE 80
ENTRYPOINT ["dotnet","applicationname.dll"]




Azure container groups 


This is a collection of containers that get scheduled on the same host machine

Example, if we have two containers one for UI and one for backend 

The containers then share same lifecycle, resources, local network and storage volumes

The deployment of a container group is done via a Resource Manager template or a YAML file. 

you can persist data via the use of Azure file shares. 


3306 is port that will expose mysql 


sudo docker run --name=mysql-instance -p 3306:3306 --restart on-failure  -d -e MYSQL_ROOT_PASSWORD=Azure123 mysql (name of my image) 


sudo docker exec -it mysql-instance mysql -uroot -p
upon prompt give password. now you can see its connected to MySQL, you can run sql commands from putty itself


creating a custom image of mysql.. 

FROM mysql as base 
ENV MYSQL_ROOT_PASSWORD=Azure123
ENV MYSQL_DATABASE=appdb
COPY 01.sql /docker-entrypoint-initdb.d/



1. We need to replace connection string server name with localhost for db. Because it will be hosted on same server. 

remove containers 

	i. sudo docker stop containername
	ii. sudo docker rm containername
remove images
	i. sudo docker images rm imagename

yaml file 

apiVersion: 2022-10-10
location: northeurope
name: sqlAppGroup
properties: 
  containers: 
   properties:
     image: regristoryname/imagename:latest
	resources:
	 requests:
	  cpu: 1
	   memoruyInGb: 1.5
	    ports: 
		- port: 3306
-name: web		
properties: 
  containers: 
   properties:
     image: regristoryname/image2name:latest
	resources:
	 requests:
	  cpu: 1
	   memoruyInGb: 1.5
	    ports: 
		- port: 80
osType: Linux
ipaddress: 
	type:Public
	ports:
	 -protocol: tcp
	   port: 80
	 imageRegistryCredentials:
	   - server: companyregistry.azurecr.io
	    username: companyregistry
	    password: dxzy
type: Microsoft.containerInstance/containerGroups


Open Cloud shell

Advanced settings

File share, storage account - create new 

Upload yml file in cloud shell.. 


az container create --resource-group resourcegroupname --file deployment.yml


based on the above yml file, this container group will have two container instances


Implementing Azure security


Azure Active Directory? 

Azure Active directory is an identity provider and access management service.

Usage: This can be used as an identity provider for Azure, Microsoft 365 and other SaaS products as well. 

You can manage identities such as users, groups and even applications

Manage security aspects when it comes to your identities


Pricing 

Free - User and group management. 

Premium P1 - Dynamic groups, hybrid identities, self-service password reset for on-premise users.

Premium P2 - Azure AD identity protecion and privileged identity Management. 


Role Based Access control

A user or Application or Azure object first needs to authenticate itself to tell who it is and then role based authentication determine what that can access

Some Predefined roles are below

Contributor
Owner
Reader 


What is Application Object?

Lets say we want our application to access Storage account. We have two ways to achieve this
	1. save access keys of storage account in our application then application will authenticate itself
	2. We can create appilcation object and that object will be given some access then it will authenticate and access storage account. Advantage of using application object is that we can give multiple storage account access to our application objects. 


Microsoft Identity platform 

The platform helps to build applications that users and customers can sign in using their Microsoft identities or social accounts



Azure Active Directory -> App registrations -> New registration - > Enter name "BlobApp" and click Register 

Go to Storage account -> Access control -> Add role assignment -> Reader role -> Select member -> select "BlobApp" -> Review and assign


Go to Storage account -> Access control -> Add role assignment -> Storage Blob Data Reader role -> Select member -> select "BlobApp" -> Review and assign


We need couple of properties to connect with bolb now. 

Application / Client ID : Overview section of Application object
Tenant ID		: Overview section of Application object
Client secret		: Certificates and secrets  section of Application object 

Certificates and secrets -> Create new client secret -> Now you will see some secret please save it in secure place, once you navigate away you cannot see this again. 



String clientId ="";
string tenantId="";
string clientSecret="";

string blobUri="";
string filePath="c:/temp/";

ClientSecretCredentials clientSecretCredential = new ClientSecretCredentials(tenantId, clientId, ClientSecret);
BlobClient blobClient = new BlobClient(new Uri(blobUri, ClientSecretCredentials );
await blobClient.DownloadToAsync(filepath);
console.WriteLine("The blob downloaded")
-- should instal Azure.Identity;



Microsoft Graph

Is an API https://graph.microsoft.com to provide access to rich, people-centric data and insights in the microsoft lcoud including Microsoft 365, Windows, and Enterprise Mobility + security. 

We are going to see how to invoke graph API using application object. In previous example, we were able to create application object and then on then blob storage account we give access control to that application object. 

But in order use this API using postman tool, postman is an external tool. For that we need to go application object -> API permissions 

By default Microsoft Graph -> User.Read (Delegated Type ) permission 

Types of Permission 
	1. Application Permission (Runs on behalf of the application)
	2. Delegated permission  (Runs on behalf of the user )

For our graph api we delete existing default permission and create application permission and -> User -> User.Read.All (Earlier it was User.Read)

Status -> Not granted for Default -> Click on Grant admin consent for Default Directory 


1. Register an application in Azure AD
2. Provide permissions
3. Provide Admin consent
4. Call the Microsoft authentication service
5. Get an access token
6. Accessa resource using the token 


how to get access key? 

Create a post request in postman. 

Go to postman application object -> Overview -> Oauth 2.0 token endpoint (v2)

Enter URL to postman 

Notice URL: https://login.microsoftonline.com/70c0xzy/oauth2/v2.0/token  -- after domain we see some random string this is directory 

x-www-form-urlencoded

Key               value
grand_type        client_credentials
client_id         from postman app object overview
client_secret     Create new secret from postman and copy here
scope             https://graph.microsoft.com/.default


Send- > 

Token type is Bearer token 


To access graph API

Create a get request from postman as below

Get : https:/graph.microsoft.com/v1.0/users 

Headers

Authorization Bearer "Token copied from post request"

Note: even there is proper permission isn't provided also we can get permission from microsoft, but that token wont have permission to access your resources.



Update user

1. Add Users.Write.All permission
2. Add -> Click on Grant admin consent for Default Directory 
3. Generate token (to get updated permission
4. Make a patch call -> https:/graph.microsoft.com/v1.0/users/userid
5. Add header values with Authorization token 
6. Body -> Raw -> JSON {"givenName":"Username"}


Key Vault 

We have sensitive information like 
	* Encryption keys
	* Certificates
	* Secrets 

We need a safe way to store this, usually we need special software to store that and server to maintain that software.  

We have Azure Key vault

1. Create new key vault 
2. Go to Keys -> Create Generate Import Key 
3. Create new project 
4. Install Azure.Security.KeyVault.Keys
5. Create new app registration  
6. Appvault -> Access Policies -> Add Policy -> Key Permission (get, Encrypt, Decrypt)  
	Select Principal -> Keyapp -> Add -> Save 
Now this permission is 
tring clientId ="";
string tenantId="";
string clientSecret="";

string KeyVaultURL=""; -- from Keyvault overview section 
string keyName="appkey"; --name of your key in azure 
string textToEncrypt ="This is a secret text";

ClientSecretCredentials clientSecretCredential = new ClientSecretCredentials(tenantId, clientId, ClientSecret);
KeyClient keyClient = new KeyClient(new Uri(keyVaultURL));

var key = keyClient.GetKey(keyName);
var cryptoClient = new CryptographyClient(key.Value.Id, clientSecretCredential );
byte[] textToBytes = Encoding.UTF8.GetBytes(textToEncrypt);
EncryptResult result = cryptoClient.Encrypt(EncryptionAlgorithm.RsaOaep, textToBytes);
console.WriteLine("The Encrypted string ")
  
console.WriteLine(Convert.ToBase64String(result.Ciphertext));


byte[] cipherTOBytes = result.Ciphertext;
DecryptResult textDecrypted = cryptoClient.Decrypt(EncryptionAlgorithm.RsaOaep,cipherTOBytes )

console.WriteLine("The Decrypted string ")
console.WriteLine(Encoding.UTF8.GetString(textDecrypted.Plaintext);



Secrets 
======================================================

1. Install Azure.Security.KeyVault.Secrets


String clientId ="";
string tenantId="";
string clientSecret="";

ClientSecretCredentials clientSecretCredential = new ClientSecretCredentials(tenantId, clientId, ClientSecret);

string keyVaultUrl="";
string secretName ="dbConnectionString" -- secret name 
SecretClient secretClient = new SecreClient(new Uri(keyVaultUrl), clientSecretCredential)

var secret = secretClient.GetSecret(secretName );
string connectionString = secret.value.value;

In Azure, Secret should have Get permission. 


Managed Identities 

A common challenge for developers is the management of secrets, credentials, certificates, and keys used to secure communication between services. Managed identities eliminate the need for developers to manage these credentials.

While developers can securely store the secrets in Azure Key Vault, services need a way to access Azure Key Vault. Managed identities provide an automatically managed identity in Azure Active Directory for applications to use when connecting to resources that support Azure Active Directory (Azure AD) authentication. Applications can use managed identities to obtain Azure AD tokens without having to manage any credentials.


If you host your application on Azure VM, then you can make use of Managed identity, where you dont have to store anything including client secret, client ID etc. This managed identity will be given access to the azure resources. This works on azure services. If your application is hosted on outside Azure environment we can use Application object. 


1. Configure managed Identity for your VM , Go to VM -> Identity -> System assigned -> Status -> On -> Save 

(you can see this alert appvm will be registered with Azure Active directory. Once it is registered, appvm can be granted permissions to access resources protected by Azure AD. Do you want to enable the system assigned managed identity for appvm?)

2. Storage account -> Access control -> Add role assignment -> add memeber -> select appvm (which is our managed identity) 
3. TokenCredential will take access token from various places like Environment, ManagedIdentity, AzureCli, SharedTokenCache etc. 
4. Download RDP for VM, right click and edit -> Local Resources -> More -> Drives -> C:\   (so local C drive files are copied to VM ) 	  

string blobUri="";
string filePath="c:/temp/";
TokenCredential tokenCredential = new DefaultAzureCredential() 
 
BlobClient blobClient = new BlobClient(new Uri(blobUri, tokenCredential );
await blobClient.DownloadToAsync(filepath);
console.WriteLine("The blob downloaded")
-- should inclue azure.core



Managed Identitiy - Getting access token

We are going to use Metadata API to get the access token, this is the way to get access token from ManagedIdentity 

169.254.169.254




string token Uri = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=http://storage.azure.com"

HttpClient client = new HttpClient ();
client.DefaultRequestHeaders.Add("Metadata","true");
HttpRespoinseMessage response = await client.GetAsync(tokenUri);
string content = await response.Content.ReadAsStringAsync();

Dictionary<string, string> values = JsonConvert.DeserializeObject<Dictionary<string, string>(content);
foreach(KeyValuePari<string, string> pair in values)
{
Console.WriteLine("key "+ pair.Key);
Console.WriteLine("Value "+ pair.Value);
}


string BlobUri ="";
HttpClient BlobClient = new HttpClient();
BlobClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", values["access_token"]);
bolbClient.DefaultRequestHeaders.Add("x-ms-version","2017-11-09"); // To do a blob call, we need to provide mentioned information, refer microsoft documentation 
HttpRespoinseMessage blobresponse = await BlobClient.GetAsync(BlobUri );
string blobContent = await blobResponse.Content.ReadAsStringAsync(); 
console.WriteLine(content);




Azure Managed Identity

Instead of giving clientId, secret etc, we can make use of Managed Identity for Product Service project. 

App service -> Identity -> System Assigned -> on -> save 

In Azure keyvalue my connection string is saved. 
Key Vault -> Access Policies ->  Get access -> Select principal -> sqlapp (appservice name) ->save

 

Managed Identity Types

1. System Assigned (this is assigned on the resource itself, like VM, Resource group etc)
2. User Assigned (This is a seperate resource)

Use of User assigned identity is even when the resource is deleted this identity will stay. And we can assign one identity to multiple resources

You have to create managed identity and assign it to VM, then on the Storage account we need to give read and blob read permission to that managed identity. 



User Assinged Identity - Powershell
========================================

-- on terminal Install-Module Az.ManagedIdentity

Connect-AzAccount 

$ResourceGroupName="app-grp"
$IdentityName="app-identity"
$VmName ="appvm"


New-AzUserAssignedIdentity -ResourceGroupName $ResourceGroupName -Name $IdentityName -Location "North Europe"

$Identity=Get-AzResource -Name $IdentityName -ResourceGroupName $ResourceGroupName 
$Id=$Identity.Id 

$vm=Get-AzVm -ResourceGroupName $ResourceGroupName -name $VmName 
Update-AzVM -ResourceGroupName $ResourceGroupName  -VM $Vm -IdentityType UserAssigned -IdentityId $Id


Managed Identity - Powershell 
===========================================
Connect-AzAccount

$ResourceGroupName="app-grp"
$VmName="appvm"

$Vm=Get-AzVM -ResourceGroupName $ResourceGroupName -Name $VmName 

Update-AzVm -ResourceGroupName $ResourceGroupName -VM $vm -IdentityType SystemAssigned 


PowerShell - Storage Account 
===============================================

$StorageAccountName = "appstore5050"
$ResourceGroupName = "app-grp"

$StorageAccountKey= (Get-AzStorageAccount -ResourceGroupName $ResourceGroupName -AccountName $StorageAccountName) | Where-Object {$_.KeyName -eq "key1"}
$StorageAccountKeyValue= $StorageAccountKey.Value  

$KeyVaultName = "appvault20303"
$SecretValue = ConvertTo-SecureString $StorageAccountKeyValue -AsPlainText  -Force 

Set -AzKeyVaultSecret  -VaultName $KeyVaultName -Name $StorageAccountName -SecretValue $SecretValue

Section 10 
###########################################################
Implement Azure Security - Authentication and Authorization
===========================================================

Microsoft Identity Platform

Where Azure Active Directory is one of the Identity provider, we are not restricted to use only AAD. We can also make use of other external identity providers like Facebook, Gmail, LinkedIn etc

Basically we are going to get a token from external identity providers and provide access based on the token. 


Microsoft Authentication Library
--------------------------------

Enable developers to acquire access tokens from the Identity platforms
This can be used to authenticate users and allow secure access to APIs
It also maintains the token cache and refresh tokens when they are about to expire. 


OAuth2
==============================================================

An application is accessing some resource on behalf of the user is what OAuth is all about. This process is called Authorization work flow. 


oauth.net/2/ will have more information including grant types
	* Authorization code
	* PKCE
	* Client Credentials 
	* Device code
	* Refresh token


Click on client credentials you can notice what is required to make client credentials like grant_type 

POST /token HTTP/1.1
Host: authorization-server.com
 
grant_type=client_credentials
&client_id=xxxxxxxxxx
&client_secret=xxxxxxxxxx

This is what we followed when we use Azure Active directory


OAuth2 - Authorization Code Grant 
==============================================================


Resource Owner - This is the user who has access to the protected resource
Client		- This is the application requesting access to the resource  
Resource Server - In Azure, this can be Web API that will allow access into the Azure resource 
Authorization Server - Microsoft Identity platform is the authorization server 


How does Authorization code flow works?

1. Application makes a call to authorization server  and will provide callback URI to Authorization server. When  Authorization server has some response to provide it can use this call back uri
2. The authorization server sends the authorization code to the application. This authorization code is just the initial step in the process. The application then needs to use the authorization code to get the access token 
(Note the authorization code is viewable in the browser, but later in the process of getting the access token with the use of the authorization code is done by the application in the backend. This is for security reason to avoid man in middle attack) 




The Authorization Code Flow

Here’s each query parameter explained:

response_type=code - This tells the authorization server that the application is initiating the authorization code flow.
client_id - The public identifier for the application, obtained when the developer first registered the application.
redirect_uri - Tells the authorization server where to send the user back to after they approve the request.
scope - One or more space-separated strings indicating which permissions the application is requesting. The specific OAuth API you’re using will define the scopes that it supports.
state - The application generates a random string and includes it in the request. It should then check that the same value is returned after the user authorizes the app. This is used to prevent CSRF attacks.
When the user visits this URL, the authorization server will present them with a prompt asking if they would like to authorize this application’s request.



Use Authentication in Web project
============================================================

1. Create web app using .net core and add below configuration in appsettings.json
   "AzureAd": {
   "Instance" : "https://login.microsoftonline.com",
   "TenantId" : "",
   "ClientId" :""
  }
2. Install Microsoft.Identity.Web  
3. Program.cs -> builder.Services.AddMicrosoftIdentityWebAppAuthentication(builder.Configuration)  // This will help us our application to authenticate itself automatically. 
app.UseAuthentication();
4. Index.cshtml.cs -> Add authorize attribute on class level
5. Go to Application object -> authenticaton -> Add platform -> Configure platform -> Enter the redirect URL 
Then Select the tokens you wold like to be issued by the authorization endpoint: -> ID tokens (used for implicit and hybrid flows)
6. Now our web application is asking us to login to Azure, lets provide credentials and login 
7. Now browser is asking permissions requested. (consent on behalf of your organization) 
Remember, in application object we gave "Grant admin consent for default directory". This is because postman has no ability to get this consent (we are not logged in as azure user account). But this case we did not enabled it, so our application is prompting user permission 
Another important point is postman is having application Type permission, means our postman itself should have permission. In this case we have delegated permission, means on user's behalf application will authorize. 

After giving our consent we are getting below error. The redirect URI https://localhost:7046/signin-oidc specified in  THE REQUEST DOES NOT MATCH THE REDIRECT UriS CONFIGURED FOR THE APPLICATION 


"AzureAd": {
   "Instance" : "https://login.microsoftonline.com",
   "TenantId" : "",
   "ClientId" :""
   "CallbackPath": "/signin-oidc"
   "SignedOutCallbackPath": "/signout-oidc"

  }

the same has to be configured Authentication section of Application object
Redirect URL
https://localhost:7046/signin-oidc
Front Channel logout url 
https://localhost:7046/signout-oidc

oidc - OpenIDConnect We are using OpenIdConnect to authenticate then Oauth to authorize. 



Adding Sign-out 
===========================================================

1. For sign-in and sign-out we need to use the following library Microsoft.Identity.Web.UI
2. builder.Services.AddControllersWithViews()
3. Place AddRazorPages below with opions

builder.Services.AddRazorPages().AddMvcOptions(options => 
{
var policy = new AuthorizationPolicyBuilder()
	.RequireAutheticatedUser()
	.Build();
	options.Filters.Add(new AuthorizeFilter(policy));
)}.AddMicrosoftIdentityUI();

// add required library using if error is popping up 

4. Remove Authorize attribute, because we are now going to use authenticated users only 
5. app.UseEndpoints(endpoings => 
endpoints.MapControllerRoute(
name: "default",
pattern: "{controller=Nome}/{action=Index}/{id?}"))

6. Add new Scaffolded Item -> Go to Identity (it will add default nuget packages that are necessary for this) ->  Choose Account\Login  and Account\Logout -> Click on Add new Data context class ->  Add SQLLite instead on SQL server. 

7. Areas -> Identity -> Data (AuthAppContext) 
		     -> Pages -> Account (Login and logout.cshtml) 
8. Program.cs also sqllite configuration and identity configuration will be added. 
9. To signout  asp-area="MicrosoftIdentity" asp-controller="Account "  asp.action="SignOut" 


Getting user claims?

Claims is nothing but information about users. 
In authentication we enabled ID tokens through which we will get information about users. 

@using System.Security.Claims

@foreach(var _claim in ((ClaimsIdentity) User.Identity).Claims)
{

<tr>
<td>@_claim.Type</td>
<td>@_claim.Value</td>
</tr>
}



Getting Group claims 
============================================================

We can create groups, add members. and give access to that group, so that whoever assigned to that group get same level of permission 

If application need certain role to access the application then the application can check what group user is assigned to and get their role based on that. 

To do that go to AuthApp -> TokenConfiguration -> Add Group claim  -> Select group types to include in Access, ID and SAML tokens -> select "Security groups"
 
Customize token properties by type -> ID -> Group ID (is default )
				      Access -> Group ID  -> Add


Go to Manifest section (it is a json file having information about our cliam) go and check groupMembershipClaims : "SecurityGroup" 

No in our claim program we should have got this group ID . We can make note of group ID which we are looking for and take action based on it. 

Apart from that we can also Add optional claim -> ID -> email, givenname
Turn on the Microsoft graph email, profile permission(required for claims to appear in token)  


Getting An Access token.
===============================================================

1. Lets say we want out applicationto access storage account to perform some action

But now, we are authenticating user and giving users permission to access storage account, but application need certain permission to access storage account. 

1. To do that API permissions ->  Add permission -> Azure storage -> Delegated permission (only this is possible) -> Permission -> user_impersonation (application will act like user and get permission to access storage account) 
2. Also Authentication -> Access tokens (used for implicit flows) 

3. program.cs 

string[] scope = new string[] {"https://storage.azure.com/user_impersonation"}
builder.Services.AddMicrosoftIdentityWebAppAuthentication(builder.Configuration, "AzureAd")
		.EnableTokenAcquisitionToCallDownstreamApi(scope);
		.AddInMemoryTokenCaches();
Now we are getting token from application like below

private readonly ITokenAcquisition _tokenAcquistion;
public string accessToken;

public IndexModel(ITokenAcquisition tokenacqu)
{
_tokenAcquistion = tokenacqu
}

public Task OnGet()
{
string[] scope = new string[] {"https://storage.azure.com/user_impersonation"}
accessToken = await _tokenAcquisition.GetAccessTokenForUserAsync(scope)
}


Not its showing error  "MsalClientException: One client credential type required either: ClientSecret, Certificate OR clientAssertion must be defined when creating a confidential client. ONly specify one. 

Go to appsetting.json

"ClientSecret" : "secretfromAzure"



Using Access Token 
====================================================================================================


 public Task OnGet()
{
//string[] scope = new string[] {"https://storage.azure.com/user_impersonation"}
//accessToken = await _tokenAcquisition.GetAccessTokenForUserAsync(scope)

TokenAcquisitionTokenCredential tokenAcquisitionTokenCredential = new TokenAcquisitionTokenCredential(_tokenAcquisition);
Uri blobUri = new Uri("");
BlobClient blob = new BlobClient(blobUri, tokenAcquisitionTokenCredential );


MemoryStream ms = new MemoryStream(ms);
blobContent = sr.ReadToEnd();

}

--install Azure.Storage.Blobs from nuget package. 

Now we can get blobcontent to our web application..

In order to publish to Azure web app, we need to update sign in and signout properties in Application object with new web app url. 


Publish as Zip option.  


Accessing Blob storage from Postman

1. Select Storage account and give access to postman application object with reader and blob read access
2. Goto Postman and in the token post request change the scope alone with below
https://storage.azure.com/default 
3. Send will get us the access token 
4. Go to storage account we will get bolburi
5. When we give access token in the header section we will get contents from azure blob. 



Creating web api & Publish is normal process. Then add authentication 
=============================================================
1. Go to manifest -> accessTokenAcceptedVersion -> change null to 2 . 2 means supporting oauth2.0 , null means oauth. 

2. In project install Microsoft.Identity.Web from nuget 
3. Program.cs -> builder.Services.AddMicrosoftIdentityWebApiAuthentication(builder.Configuration,"")


3. In appsettings.json -> add AzureAd section with clientid, TenantId, Instance details
4. App.userAuthentication() and App.UseAuthorization();
5. Now accessing URL will give 401 error 
(as our postman tool cannot login as user, we need to create an application object for API project ProductAPI)
6. Go to "Expose an API " -> Application ID URI -> SET -> will populate one api(scopes defined by this API . Define custom scopes to restrict access to data and functionlaity protected by the API. An applicationthat requires access to parts of this API can request that a user or admin consent to one or more of these.
Adding a scope here creates only delegated permissoins. If you are looking to create application-only scopes, use 'App roles' and define app roles assignable to application type. Go to app roles. 
7. Copy the api and paste it in scope when getting access token 

8. GO to post man -> API permission ->  select our Produt API -> Application permission (we have this ) -> Permissions -> ProductAccess -> Add permission -> Add Admin consent	  
 
Go to Product API application object and Add roles ->  
  


Invoking API from console application 


IcConfidentialClientApplication cca ;

string clientid="";
string clientSecret="";
string tenantId = "";

cca = ConfidentialClientApplication.Create(clientId)
	.WithTnenatId(tenantId)
	.WithClientSecret(clientSecret)
	.Build();

string[] scopes = new string[] {"api/xy/.default"} 
AuthenticationResult result = await cca.AcquireTokenForClient(scope).ExecuteAsync();
 
string accessTOken = result.AccessToken;
Console.WriteLine(accessToken);

string apiURL="WebAPI url";

HttpCLient client = new HttpClient();
client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer" , accessToken );


HttpResponseMessage responseMessage = await client.SendAsync(apiUrl);
string content = await resonpseMessage.Content.ReadAsStringAsync();
